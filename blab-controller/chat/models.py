"""Conversation - data models."""

import shlex
import uuid

from django.core.exceptions import ValidationError
from django.db import models
from django.utils.translation import gettext_lazy as gettext
from django.utils.translation import pgettext_lazy as pgettext
from overrides import overrides


class Conversation(models.Model):
    """Represents a chat conversation."""

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
        help_text=gettext("the conversation id, with 32 characters"),
    )

    name = models.CharField(
        pgettext("conversation name", "name"),
        max_length=50,
        blank=True,
        null=True,
        help_text=gettext("the conversation name, which can be blank"),
    )

    created_at = models.DateTimeField(
        gettext("time"),
        auto_now_add=True,
        help_text=gettext("the instant when the conversation started"),
    )

    class Meta:
        verbose_name = gettext("conversation")
        verbose_name_plural = gettext("conversations")

    def __str__(self) -> str:
        return f"Conversation(id={self.id})"


class Participant(models.Model):
    """Represents a chat participant (person or bot)."""

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
        help_text=gettext("the participant id, with 32 characters"),
    )

    name = models.CharField(
        gettext("participant"),
        max_length=50,
        help_text=gettext("name of the participant"),
    )

    HUMAN = "H"
    """a human participant"""

    BOT = "B"
    """a bot participant"""

    TYPE_CHOICES = [
        (HUMAN, gettext("human")),
        (BOT, gettext("bot")),
    ]
    type = models.CharField(
        gettext("type"),
        max_length=1,
        choices=TYPE_CHOICES,
        default=None,
        help_text=gettext("the participant type (`H` = human, `B` = bot)"),
    )

    conversation = models.ForeignKey(
        Conversation,
        on_delete=models.PROTECT,
        verbose_name=pgettext("conversation", "participants"),
        related_name="participants",
        help_text=gettext("the conversation to which the participant belongs"),
    )

    class Meta:
        verbose_name = gettext("participant")
        verbose_name_plural = gettext("participants")

    def __str__(self) -> str:
        return self.__repr__()

    def __repr__(self) -> str:
        # noinspection PyTypeChecker
        return f"Participant({self.id}, name={shlex.quote(self.name)})"


def _attachment_name(m: "Message", _fn: str) -> str:
    fn = f"chat_{str(m.conversation.id)}/msg_{str(m.m_id)}_{str(m.file_key)}"
    return "chat/" + fn.replace("-", "")


class Message(models.Model):
    """Represents a message in a conversation."""

    m_id = models.UUIDField(
        unique=True,
        default=uuid.uuid4,
        editable=False,
        db_index=True,
        help_text=gettext("the 32-character message id"),
    )

    # Note that a separate numerical ID used internally
    # (not exposed to clients) as a primary key

    class MessageType(models.TextChoices):
        """Contains types of messages."""

        SYSTEM = ("S", gettext("System"))
        """Messages generated by the system"""

        TEXT = ("T", gettext("Text"))
        """Text messages"""

        VOICE = ("V", gettext("Voice"))
        """Voice messages (recorded on the website)"""

        AUDIO = ("a", gettext("Audio"))
        """Messages with an audio file"""

        VIDEO = ("v", gettext("Video"))
        """Messages with a video file"""

        IMAGE = ("i", gettext("Image"))
        """Messages with an image file"""

        ATTACHMENT = ("A", gettext("Attachment"))
        """Messages with arbitrary file attachments"""

    type = models.CharField(
        max_length=1,
        choices=MessageType.choices,
        help_text=gettext(
            "the type of the message "
            "(`S` = system, `T` = text, `V` = voice, `a` = audio, "
            "`v` = video, `i` = image, `A` = arbitrary attachment) "
        ),
    )

    conversation = models.ForeignKey(
        Conversation,
        related_name="messages",
        on_delete=models.CASCADE,
        verbose_name=gettext("message"),
        help_text=gettext("the conversation to which the message belongs"),
    )

    time = models.DateTimeField(
        gettext("time"),
        auto_now_add=True,
        help_text=gettext("when the message was sent or the event occurred"),
    )

    quoted_message = models.ForeignKey(
        "self",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        verbose_name=gettext("quoted message"),
        help_text=gettext("the message quoted by this message, if any"),
    )

    sender = models.ForeignKey(
        Participant,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        verbose_name=gettext("sender"),
        help_text=gettext("who sent this message (NULL for system messages)"),
    )

    class ApprovalStatus(models.IntegerChoices):
        """Contains the situations a message can be in regarding approval."""

        NO = 0, gettext("not approved")
        AUTOMATICALLY_APPROVED = 1, gettext("automatically approved")
        APPROVED_BY_BOT_MANAGER = 2, gettext("approved by bot manager")

    approval_status = models.IntegerField(
        gettext("approval status"),
        choices=ApprovalStatus.choices,
        default=ApprovalStatus.NO,
        help_text=gettext("the approval status of the message"),
    )

    class SystemEvent:
        CREATED = "conversation-created"
        JOINED = "participant-joined"
        LEFT = "participant-left"
        ENDED = "conversation-ended"

    text = models.CharField(
        gettext("text"),
        max_length=4000,
        blank=True,
        help_text=gettext("the text contents of the message"),
    )
    # note: includes optional captions for messages with file attachments
    # and event types for system messages

    additional_metadata = models.JSONField(
        gettext("additional metadata"),
        default=dict,
        blank=True,
        help_text=gettext(
            "additional metadata about the message "
            "(usually system messages, with the key `participant_id`)"
        ),
    )

    original_file_name = models.CharField(
        gettext("original file name"),
        max_length=100,
        blank=True,
        null=True,
        help_text=gettext(
            "original name of the file attached to the message "
            "(it may not be set for files that are hosted externally)"
        ),
    )

    file_key = models.UUIDField(
        default=uuid.uuid4,
        editable=False,
        help_text=gettext(
            "key required to access the file "
            "(not set for files that are hosted externally)"
        ),
    )

    file = models.FileField(
        gettext("attached file"),
        null=True,
        blank=True,
        max_length=256,
        upload_to=_attachment_name,
        help_text=gettext(
            "the file attached to the message "
            "(not set for files that are hosted externally)"
        ),
    )

    file_size = models.PositiveBigIntegerField(
        blank=True,
        null=True,
        help_text=gettext(
            "file size in bytes (usually not set for files that are hosted externally)"
        ),
    )

    mime_type = models.CharField(
        gettext("MIME type"),
        max_length=256,
        blank=True,
        null=True,
        help_text=gettext("MIME type of the file attached to the message"),
    )

    external_file_url = models.URLField(
        gettext("external file URL"),
        max_length=1000,
        blank=True,
        help_text=gettext(
            "external URL of the attached file "
            "(only set for files that are hosted externally)"
        ),
    )

    local_id = models.CharField(
        gettext("local message id"),
        blank=True,
        null=True,
        max_length=32,
        help_text=gettext("local message id, defined by the sender"),
    )

    # Note:
    # Subsequent attempts to send a message with the same local id from the
    # same sender are ignored.
    # The sender should include a unique local_id per message, and it can be used
    # to identify each message when it is returned by the server.

    command = models.CharField(
        gettext("command"),
        max_length=1000,
        blank=True,
        help_text=gettext(
            "a JSON-encoded command (only in messages sent by manager bots)"
        ),
    )

    sent_by_manager = models.BooleanField(
        gettext("sent by manager"),
        default=False,
        help_text=gettext("whether the message was sent by the manager bot"),
    )

    # Note:
    # The manager bot can send messages on behalf of other participants.
    # The field above can be used to tell whether the message was actually sent by
    # the associated participant.

    class Meta:
        verbose_name = gettext("message")
        verbose_name_plural = gettext("messages")
        constraints = [
            models.UniqueConstraint(
                fields=["conversation", "sender", "local_id"], name="local_id_unique"
            )
        ]

    def __str__(self) -> str:
        text = self.text
        return f"Message(id={self.id}, {text=})"

    @overrides
    def clean(self) -> None:
        super().clean()
        # hasattr check is necessary, otherwise Django throws an exception
        # if the member does not exist
        sender = getattr(self, "sender", None) if hasattr(self, "sender") else None
        if self.type == Message.MessageType.SYSTEM:
            if sender:
                error = "system message must not have a sender"
                raise ValidationError(error)
        else:
            if not sender:
                error = "non-system message must have a sender"
                raise ValidationError(error)
            if sender not in self.conversation.participants.all():
                error = "sender is a participant in the conversation"
                raise ValidationError(error)

    def sent_by_human(self) -> bool:
        """Check if this message was sent by a person.

        Returns
        -------
            `True` if and only if the message was sent by a human user
        """
        return (
            self.type != Message.MessageType.SYSTEM
            and self.sender.type == Participant.HUMAN
        )


class MessageOption(models.Model):
    """Represents one of the options given to the user."""

    option_text = models.CharField(
        gettext("option text"),
        max_length=4000,
        blank=True,
        help_text=gettext("text of the option"),
    )

    position = models.PositiveSmallIntegerField(
        gettext("option position"), help_text=gettext("the position of the option")
    )

    message = models.ForeignKey(
        Message,
        related_name="options",
        on_delete=models.CASCADE,
        verbose_name=gettext("message"),
        help_text=gettext("the message to which the option belongs"),
    )

    class Meta:
        ordering = ["position"]

    def __str__(self) -> str:
        option_text, position = self.option_text, self.position
        message_id = self.message.id
        return f"MessageOption({option_text=}, {position=}, {message_id=})"
